# java 基础 01

- [java 基础 01](#java-基础-01)
  - [java 取模与取余的区别](#java-取模与取余的区别)
  - [你知道HashMap底层的数据结构是什么吗](#你知道hashmap底层的数据结构是什么吗)
  - [JDK 1.8中对hash算法和寻址算法是如何优化的呢](#jdk-18中对hash算法和寻址算法是如何优化的呢)
  - [你知道HashMap是如何解决hash碰撞问题的吗？](#你知道hashmap是如何解决hash碰撞问题的吗)
  - [说说HashMap是如何进行扩容的可以吗？](#说说hashmap是如何进行扩容的可以吗)
  - [说说synchronized关键字的底层原理是什么？](#说说synchronized关键字的底层原理是什么)
  - [能聊聊你对CAS的理解以及其底层实现原理可以吗 ?](#能聊聊你对cas的理解以及其底层实现原理可以吗-)
  - [ConcurrentHashMap实现线程安全的底层原理到底是什么？](#concurrenthashmap实现线程安全的底层原理到底是什么)
  - [你对JDK中的AQS理解吗？AQS的实现原理是什么？](#你对jdk中的aqs理解吗aqs的实现原理是什么)
  - [说说线程池的底层工作原理可以吗？](#说说线程池的底层工作原理可以吗)

## java 取模与取余的区别

1, 对于整型数a，b来说，取模运算或者求余运算的方法都是：
  
- 第一步：求 整数商： c = a/b;

- 第二步：计算模或者余数： r = a - c * b

> 求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。

例如计算：-7 Mod 4
那么：a = -7；b = 4；

- 第一步：求整数商c，如进行求模运算c = -2（**向负无穷方向舍入**），求余c = -1（**向0方向舍入**）；

- 第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。

2, 归纳：当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。
  
- 当符号不一致时，结果不一样。**求模运算结果的符号和b（除数）一致，求余运算结果的符号和a（被除数）一致**。

- 另外各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。

3，Java程序示例：

``` java
public static void main(String[] args) {
        System.out.println("-3,2取模"+Math.floorMod(-3,2));
        System.out.println("-3,2取余"+ -3%2);
        System.out.println("3,-2取模"+Math.floorMod(3,-2));
        System.out.println("3,-2取余"+ 3%-2);
    }

```

运行结果：

``` java
-3,2取模=1
-3,2取余=-1
3,-2取模=-1
3,-2取余=1

```

## 你知道HashMap底层的数据结构是什么吗

1，底层的数据结构是：**数组**

详情说明(举例)：

``` java
HashMap<String, String> map = new HashMap<String, String>();
map.put(“张三”, “测试数据”);
map.put(“李四”, “测试数据”);
```

- hashmap的存值过程：
  
对key"张三"计算出来一个hash值，根据这个hash值对数组进行取模，就会定位到数组里的一个元素中去.

``` java
[<>, <>, <>, <>,<张三, 测试数据>, <>,<>,<李四, 测试数据>,<>, <>, <>, <>,<>, <>, <>, <>]

array[4] = <张三, 测试数据>
```

- hashmap取值的过程

map.get(“张三”) -> hash值 -> 对数组长度进行取模 -> return array[4]

## JDK 1.8中对hash算法和寻址算法是如何优化的呢

1,hash算法的优化：对每个hash值，在他的低16位中，让高低16位进行了异或，让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现冲突，大家可能会进入数组的同一个位置

2,寻址算法的优化：用与运算替代取模，提升性能

- hash算法优化详情：

源码

``` java
      // JDK 1.8以后的HashMap里面的一段源码
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

```

``` java
// key.hashCode()比如说：有一个key的hash值 A
1111 1111 1111 1111 1111 1010 0111 1100
// A >>> 16 这是向右移动16位后的值 B
0000 0000 0000 0000 1111 1111 1111 1111 
// 这是 A ^ B  (A 异或 B) 的值
1111 1111 1111 1111 0000 0101 1000 0011 -> int值，32位。
```

这样就实现了：让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现的冲突

>因为hash值一样 -> 他们其实都会在数组里放在一个位置，进行复杂的hash冲突的处理，将影响性能。

hash值对数组长度取模，定位到数组的一个位置，将key-value塞数组里面就ok了

- 寻址算法优化

优化的核心点是：

```java
将hash对n取模 -> 数组里的一个位置 

改成：
(n - 1) & hash -> 数组里的一个位置

得到的数组位置是一样的，(n - 1) & hash的性能更高。

同时注意：（n-1）主要是和 hash 的低16位进行与运算。
高16位之间的与运算，是可以忽略的，核心点在于低16位的与运算，hash值的高16位没有参与到与运算里来。

// 当只有高16位不一样时，我们进行高16位低16位异或运算，从而实现hash的低16位不一样。
1111 1111 1111 1111 1111 1010 0111 1100 -> （异或后：）1111 1111 1111 1111 0000 0101 1000 0011

1111 1111 1111 1110 1111 1010 0111 1100 -> （异或后：）1111 1111 1111 1110 0000 0101 1000 0010

```

hash & (n - 1) -> 效果是跟hash对n取模，效果是一样的，但是与运算的性能要比hash对n取模要高很多，数学问题，**数组的长度会一直是2的n次方**。

>说明: hash & (n - 1) 中的hash值也是经过上面优化过后的值（即：他的低16位同时保持了高低16位的特征）

## 你知道HashMap是如何解决hash碰撞问题的吗？

1，hash冲突问题，链表+红黑树，O(n)和O(logn)。

> 尽管jdk1.8做了 map.put和map.get -> hash算法优化（避免hash冲突），寻址性能优化。

> 算出key的hash值，到数组中寻址，找到一个位置，把key-value对放进数组，或者从数组里取出来

> 但是两个key，多个key，他们算出来的hash的值，和n-1，与运算之后，发现定位出来的数组的位置还是一样的，还是会出现hash碰撞或者叫hash冲突。

- 这时怎么处理呢？
  
1，会在这个位置挂一个链表，这个链表里面放入多个元素，让多个key-value对，同时放在数组的一个位置里。例如：

```java
[<> -> <> -> <>, ]
array[0]这个位置，就是一个链表
```

get取值时，如果定位到数组里发现这个位置挂了一个链表，此时遍历链表O(n)，从里面找到自己的要找的那个key-value对就可以了

2，假设你的链表很长，可能会导致遍历链表性能会比较差。

所以链表的长度达到了一定的长度之后，其实会把**链表转换为红黑树**，遍历一颗红黑树找一个元素，此时O(logn)，性能会比链表遍历O(n)高一些。

## 说说HashMap是如何进行扩容的可以吗？

1，2倍扩容
HashMap底层是一个数组，当这个数组满了之后，他就会自动进行扩容，变成一个更大的数组，让你在里面可以去放更多的元素。

2，判断新数组（n-1）& hash 的二进制结果中是否多出一个bit的1，如果没多，那么就是原来的index位置，如果多了出来，那么就是 **原index + oldCap（为原数组length）**，通过这个方式，就避免了rehash的时候，用每个hash对新数组.length取模，取模性能不高，位运算的性能比较高。

3，扩容可能带来的变化过程
[16位的数组，<> -> <> -> <>]
[32位的数组，<> -> <>, <>]
扩容后，原来数组同一位置上的链结构可能被拆分到另外的位置上去。

例如：数组长度是 16时, hash1和hash2会在数组的同一个位置上，出现一个hash冲突的问题，用链表来处理。

``` java
n - 1     0000 0000 0000 0000 0000 0000 0000 1111
hash1     1111 1111 1111 1111 0000 1111 0000 0101
&结果     0000 0000 0000 0000 0000 0000 0000 0101    = 5（index = 5的位置）
 
n - 1    0000 0000 0000 0000 0000 0000 0000 1111
hash2    1111 1111 1111 1111 0000 1111 0001 0101
&结果    0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）

```

如果数组的长度扩容之后 = 32，重新对每个hash值进行寻址，也就是用每个hash值跟新数组的length - 1进行与操作：

```java
n-1       0000 0000 0000 0000 0000 0000 0001 1111
hash1     1111 1111 1111 1111 0000 1111 0000 0101
&结果     0000 0000 0000 0000 0000 0000 0000 0101 = 5（index = 5的位置）
 
n-1       0000 0000 0000 0000 0000 0000 0001 1111
hash2     1111 1111 1111 1111 0000 1111 0001 0101
&结果     0000 0000 0000 0000 0000 0000 0001 0101 = 21（index = 21的位置）

```

hash1和hash2将在新数组中的不同位置。位置变化规律请参考第2点。

## 说说synchronized关键字的底层原理是什么？

1,synchronized底层的原理，是跟jvm指令和monitor有关系的。
如果我要是对synchronized往深了讲，他是可以很深很深的，内存屏障的一些东西，cpu之类的硬件级别的原理，原子性、可见性、有序性，指令重排，JDK对他实现了一些优化，偏向锁。

<div align='center'>
<img src=./images/java-基础01/java-基础01_2020-01-06-16-48-48.png width='80%'/></div>
<br/>

你如果用到了synchronized关键字，在底层编译后的jvm指令中，会有monitorenter和monitorexit两个指令

```java
monitorenter
 
// 代码对应的指令
 
monitorexit
```

2,那么monitorenter和monitorexit指令执行的时候会干什么呢？

- 他里面的原理和思路大概是这样的，monitor里面有一个计数器，从0开始的。如果一个线程要获取monitor的锁，就看看他的计数器是不是0，如果是0的话，那么说明没人获取锁，他就可以获取锁了，然后对计数器加1
  
- 这个monitor的锁是支持重入加锁的，什么意思呢，好比下面的代码片段。
如果一个线程第一次synchronized那里，获取到了myObject对象的monitor的锁，计数器加1，然后第二次synchronized那里，会再次获取myObject对象的monitor的锁，这个就是重入加锁了，然后计数器会再次加1，变成2

```java
// 线程1
synchronized(myObject) {  // 类的class对象来走的,加锁，一般来说都是必须对一个对象进行加锁
// 一大堆的代码
    synchronized(myObject) {
    // 一大堆的代码
    }
}

```

- 每个对象都有一个关联的monitor，比如一个对象实例就有一个monitor，一个类的Class对象也有一个monitor，如果要对这个对象加锁，那么必须获取这个对象关联的monitor的lock锁

- 这个时候，其他的线程在第一次synchronized那里，执行monitorenter会发现说myObject对象的monitor锁的计数器是大于0的，意味着被别人加锁了，然后此时线程就会进入block阻塞状态，什么都干不了，就是等着获取锁
  
- 接着如果线程1出了synchronized修饰的代码片段的范围，在底层，就会有一个monitorexit的指令。此时获取锁的线程就会对那个对象的monitor的计数器减1，如果有多次重入加锁就会对应多次减1，直到最后，计数器是0

- 然后后面block住阻塞的线程，会再次尝试获取锁，但是只有一个线程可以获取到锁。

## 能聊聊你对CAS的理解以及其底层实现原理可以吗 ? 

<div align='center'><img src=./images/java-基础01/java-基础01_2020-01-06-17-19-05.png width='80%'/></div><br/>

<div align='center'><img src=./images/java-基础01/java-基础01_2020-01-06-17-19-23.png width='100%'/></div><br/>

CAS:取值，询问，修改

多个线程他们可能要访问同一个数据
 
HashMap map = new HashMap();
 
此时有多个线程要同时读写类似上面的这种内存里的数据，此时必然出现多线程的并发安全问题。
 
我们可能要用到并发包下面的很多技术，例如：synchronized

synchronized(map) {
   // 对map里的数据进行复杂的读写处理
}
 
并发包下面的其他的一些技术，例如CAS
 
一段代码（非CAS实现）：
 
<div align='center'><img src=./images/java-基础01/java-基础01_image.png.png width='80%'/></div><br/>
 
此时，synchronized他的意思就是针对当前执行这个方法的myObject对象进行加锁
 
只有一个线程可以成功的堆myObject加锁，可以对他关联的monitor的计数器去加1，加锁，一旦多个线程并发的去进行synchronized加锁，串行化，效率并不是太高，很多线程，都需要排队去执行。

CAS的全称：compare and set 比较和设置。
CAS去进行安全的累加代码：

<div align='center'><img src=./images/java-基础01/java-基础01_2020-01-06-17-21-00.png width='80%'/></div><br/>
 
CAS在底层的硬件级别给你保证一定是原子的，同一时间只有一个线程可以执行CAS，先比较再设置，其他的线程的CAS同时间去执行此时会失败

## ConcurrentHashMap实现线程安全的底层原理到底是什么？

1，JDK 1.8以前，多个数组，分段加锁，一个数组一个锁。

2，JDK 1.8以后，优化细粒度，一个数组，每个元素先进行CAS，如果失败说明有人put过值了，此时synchronized对这个数组元素加锁，链表+红黑树处理。jdk1.8+是对数组每个元素加锁。

- 多个线程要访问同一个数据，synchronized加锁，CAS去进行安全的累加，去实现多线程场景下的安全的更新一个数据的效果，比较多的一个场景下，可能就是多个线程同时读写一个HashMap,如果给HashMap加一个synchronized，效率将会很低，也没这个必要。
  
```
// 多个线程过来，线程1要put的位置是数组[5]，线程2要put的位置是数组[21]，
//这种情况下根本不需要synchronized同步，同步了反而会降低效率，明显不好。
map.put(xxxxx,xxx);
//数组里有很多的元素，除非是对同一个元素执行put操作，此时的多线程是需要进行同步的
```

- 所以 JDK并发包里推出了一个ConcurrentHashMap，他默认实现了线程安全性。实现过程如下：

> HashMap的一个底层的原理，本身是一个大的一个数组，[有很多的元素]

（1），在JDK 1.7以及之前的版本里，将这个大的数组分段成多个数组
 
[数组1] , [数组2]，[数组3] -> 每个数组都对应一个锁，分段加锁
 
// 多个线程过来，线程1要put的位置是数组1[5]，线程2要put的位置是数组2[21]

（2），JDK 1.8以及之后，做了一些优化和改进，锁粒度的细化。
 
[一个大的数组]，数组里每个元素进行put操作，都是有一个不同的锁，刚开始进行put的时候，如果两个线程都是在数组[5]这个位置进行put，这个时候，对数组[5]这个位置进行put的时候，采取的是CAS的策略
 
同一个时间，只有一个线程能成功执行这个CAS，就是说他刚开始先获取一下数组[5]这个位置的值，null，线程1然后执行CAS，put进去我的这条数据，同时，其他的线程执行CAS，都会失败
 
通过对数组每个元素执行CAS的策略，如果是很多线程对数组里不同的元素执行put，大家是没有关系的，如果其他人失败了，其他人此时会发现说，数组[5]这位置，已经有人放进去值了，synchronized对数组这个元素加锁。

## 你对JDK中的AQS理解吗？AQS的实现原理是什么？

1，AQS ：Abstract Queue Synchronizer，抽象队列同步器。

```
ReentrantLock lock = new ReentrantLock(true);  => 公平锁
//ReentrantLock lock = new ReentrantLock();  => 非公平锁，默认是非公平锁
// 多个线程过来，都尝试
lock.lock();
// 进来的线程 执行的一堆代码TODO
lock.unlock();

```

上面代码ReentrantLock对象使用时的执行过程
state变量 -> CAS -> 失败后进入队列等待 -> 释放锁后唤醒

2， 实现原理图

<div align='center'><img src=./images/java-基础01/java-基础01_2020-01-07-16-08-08.png width='80%'/></div><br/>

<div align='center'><img src=./images/java-基础01/java-基础01_2020-01-07-16-21-22.png width='80%'/></div><br/>

<div align='center'><img src=./images/java-基础01/java-基础01_2020-01-07-16-28-09.png width='80%'/></div><br/>

> 公平锁执行原理图中： 线程3 先看一下等待队列是否 有人排队，有，直接进入等待队列排队。没有，当然是去获取锁咯。

## 说说线程池的底层工作原理可以吗？

原理图1：

<div align='center'><img src=./images/java-基础01/java-基础01_2020-01-07-17-37-28.png width='80%'/></div><br/>

原理图2：

<div align='center'><img src=./images/java-基础01/java-基础01_2020-01-07-17-40-24.png width='80%'/></div><br/>

代码：

```
ExecutorService threadPool = Executors.newFixedThreadPool(3) // 3: corePoolSize
 
threadPool.submit(new Callable() {
       public void run() {}
})；
```

提交任务，先看一下线程池里的线程数量是否小于corePoolSize，也就是3，如果小于，直接创建一个线程出来执行你的任务
 
如果执行完你的任务之后，这个线程是不会死掉的，他会尝试从一个无界的LinkedBlockingQueue里获取新的任务，如果没有新的任务，此时就会阻塞住，等待新的任务到来
 
你持续提交任务，上述流程反复执行，只要线程池的线程数量小于corePoolSize，都会直接创建新线程来执行这个任务，执行完了就尝试从无界队列里获取任务，直到线程池里有corePoolSize个线程
 
接着再次提交任务，会发现线程数量已经跟corePoolSize一样大了，此时就直接把任务放入队列中就可以了，线程会争抢获取任务执行的，如果所有的线程此时都在执行任务，那么无界队列里的任务就可能会越来越多
 
fixed，队列，LinkedBlockingQueue，无界阻塞队列